{
  "cells": [
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "---\n",
        "title: \"Final project: Data and Programming for Public Policy II\"\n",
        "author: \"Cristian Bancayan, Sol Rivas Lopes & Claudia Felipe\"\n",
        "date: \"12-04-2024\"\n",
        "format: \n",
        "  pdf:\n",
        "    include-in-header: \n",
        "       text: |\n",
        "         \\usepackage{fvextra}\n",
        "         \\DefineVerbatimEnvironment{Highlighting}{Verbatim}{breaklines,commandchars=\\\\\\{\\}}\n",
        "include-before-body:\n",
        "  text: |\n",
        "    \\RecustomVerbatimEnvironment{verbatim}{Verbatim}{\n",
        "      showspaces = false,\n",
        "      showtabs = false,\n",
        "      breaksymbolleft={},\n",
        "      breaklines\n",
        "    }\n",
        "output:\n",
        "  echo: false\n",
        "  eval: false\n",
        "---\n",
        "\n",
        "\n",
        "# Set-up\n"
      ],
      "id": "52b5cfe4"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "#------------------------\n",
        "#       Settings\n",
        "#------------------------\n",
        "\n",
        "# Packages \n",
        "#------------------------\n",
        "import os\n",
        "import pandas as pd\n",
        "import altair as alt\n",
        "import numpy as np\n",
        "from altair_saver import save\n",
        "import seaborn as sns\n",
        "import matplotlib.pyplot as plt\n",
        "from linearmodels.panel import PanelOLS\n",
        "import statsmodels.api as sm\n",
        "from scipy.stats import ttest_ind\n",
        "import statsmodels.formula.api as smf\n",
        "\n",
        "# Working directory\n",
        "#------------------------\n",
        "username = os.getlogin()\n",
        "\n",
        "# Define paths for each user of this project\n",
        "paths = {\n",
        "    \"Cristian\": r\"C:\\Users\\Cristian\\Documents\\GitHub\\ppha30538_fall2024\\python_final_proj\",\n",
        "    \"solch\": r\"C:\\Users\\solch\\OneDrive\\Documentos\\2024 - autumn quarter\\python II\\python_final_proj\",\n",
        "    \"clfel\": r\"C:\\Users\\clfel\\Documents\\GitHub\\Python II\\python_final_proj\"\n",
        "}\n",
        "\n",
        "# Changing wd depending on the user:\n",
        "if username in paths:\n",
        "    os.chdir(paths[username])\n",
        "    print(f\"Directory changed to: {os.getcwd()}\")\n",
        "else:\n",
        "    print(f\"No predefined path for user: {username}\")\n",
        "\n",
        "# Note: Please update with the path of your folder and computer user."
      ],
      "id": "06e593f6",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "## Data cleaning and merging\n"
      ],
      "id": "31abf971"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "# Open data\n",
        "education_data = pd.read_csv(\"data/cleaned/all_education.csv\")\n",
        "infrastructure_data = pd.read_csv(\"data/cleaned/all_infrastructure_housing.csv\")\n",
        "\n",
        "# Merge both datasets\n",
        "merged_edu_infra_data = pd.merge(education_data, infrastructure_data, on=['country', 'year', 'year_cct'], how='outer')\n",
        "\n",
        "# Exclude Colombia and Argentina from the dataset (does not have info before CCT)\n",
        "merged_edu_infra_data = merged_edu_infra_data[\n",
        "    (merged_edu_infra_data['country'] != 'Colombia') & \n",
        "    (merged_edu_infra_data['country'] != 'Argentina')\n",
        "]\n",
        "\n",
        "# Identify when they have the CCT: we create a dummy for the analysis\n",
        "merged_edu_infra_data['year_cct'] = merged_edu_infra_data['year_cct'].replace(0, np.nan)\n",
        "merged_edu_infra_data['cct_active'] = (merged_edu_infra_data['year'] >= merged_edu_infra_data['year_cct']) & merged_edu_infra_data['year_cct'].notna()\n",
        "merged_edu_infra_data['cct_active'] = merged_edu_infra_data['cct_active'].astype(int)\n",
        "\n",
        "# Filter countries with CCT\n",
        "countries_with_cct_df = merged_edu_infra_data[merged_edu_infra_data['year_cct'].notna()]"
      ],
      "id": "4ed0638c",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "# Country-Aggregated Education Outcomes over Time\n",
        "\n",
        "In this section, we create visualizations to compare the median values of key outcome variables over time between rural and urban areas for all Latin American countries with conditional cash transfer (CCT) programs, excluding Colombia and Argentina. This approach allows us to observe trends and differences across the region, providing insights into the potential impact of CCT programs. By focusing on median values, we minimize the influence of outliers and better capture central tendencies in the data.\n"
      ],
      "id": "2bee7e3a"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "graphs_dir = os.path.join(os.getcwd(), \"Graphs\")\n",
        "os.makedirs(\"Graphs\", exist_ok=True)\n",
        "\n",
        "# List of outcomes to include in the analysis\n",
        "outcomes = ['years_edu_all', 'enrollment6_12yo', 'enrollment13_17yo']\n",
        "\n",
        "# Separate rural and urban data\n",
        "rural_data = countries_with_cct_df[[\n",
        "    'country', 'year', 'cct_active'] + [f\"{var}_rural\" for var in outcomes]].copy()\n",
        "urban_data = countries_with_cct_df[[\n",
        "    'country', 'year', 'cct_active'] + [f\"{var}_urban\" for var in outcomes]].copy()\n",
        "\n",
        "# Rename columns to unify structure\n",
        "rural_data.columns = ['country', 'year', 'cct_active'] + outcomes\n",
        "urban_data.columns = ['country', 'year', 'cct_active'] + outcomes\n",
        "\n",
        "# Add 'area' column to differentiate rural and urban\n",
        "rural_data['area'] = 'rural'\n",
        "urban_data['area'] = 'urban'\n",
        "\n",
        "# Combine both datasets\n",
        "combined_data = pd.concat([rural_data, urban_data], ignore_index=True)\n",
        "\n",
        "# Aggregate data: Calculate the median for each year and area for each variable\n",
        "aggregated_data = combined_data.melt(\n",
        "    id_vars=['country', 'year', 'cct_active', 'area'],\n",
        "    value_vars=outcomes,\n",
        "    var_name='variable',\n",
        "    value_name='value'\n",
        ").groupby(['year', 'area', 'variable']).agg(\n",
        "    median_value=('value', 'median')\n",
        ").reset_index()\n",
        "\n",
        "# Creating custom, informative titles for each plot\n",
        "custom_titles = {\n",
        "    'years_edu_all': 'Years of Education',\n",
        "    'enrollment6_12yo': 'Proportion of 6- to 12-year-olds Enrolled in School',\n",
        "    'enrollment13_17yo': 'Proportion of 13- to 17-year-olds Enrolled in School'\n",
        "}\n",
        "\n",
        "# Creating custom, informative y-axis titles for each plot\n",
        "custom_y = {\n",
        "    'years_edu_all': 'Years of Education',\n",
        "    'enrollment6_12yo': 'Enrollment (%)',\n",
        "    'enrollment13_17yo': 'Enrollment (%)'\n",
        "}\n",
        "\n",
        "# List with all years of implementation\n",
        "cct_years = np.unique(countries_with_cct_df[\"year_cct\"]).astype(int).tolist()\n",
        "\n",
        "# Loop through each variable and create a separate chart\n",
        "for var in outcomes:\n",
        "    # Filter data for the current variable\n",
        "    data_for_var = aggregated_data[aggregated_data['variable'] == var]\n",
        "\n",
        "    # Create the chart\n",
        "    chart = alt.Chart(data_for_var).mark_line(point=True).encode(\n",
        "        x=alt.X('year:O', axis=alt.Axis(title='Year')),\n",
        "        y=alt.Y('median_value:Q', axis=alt.Axis(\n",
        "            title=f'Median {custom_y[var]}')),\n",
        "        color=alt.Color('area:N',\n",
        "                        scale=alt.Scale(domain=['urban', 'rural'],\n",
        "                                        range=['#363633', '#89a6a5']),  \n",
        "                        legend=alt.Legend(title='Region Type',\n",
        "                                          labelFontSize=12,\n",
        "                                          titleFontSize=14)),\n",
        "        tooltip=['year', 'median_value', 'area']\n",
        "    ).properties(\n",
        "        width=600,\n",
        "        height=400,\n",
        "        title=f\"Median {custom_titles[var]}: Rural vs. Urban\"\n",
        "    )\n",
        "\n",
        "    vertical_lines = alt.Chart(pd.DataFrame({'year': cct_years})).mark_rule(\n",
        "        color='red',  \n",
        "        strokeDash=[4, 4]  # Dotted line style\n",
        "    ).encode(\n",
        "        x='year:O'\n",
        "    )\n",
        "\n",
        "    label = alt.Chart(pd.DataFrame({'year': [cct_years],\n",
        "                                    'label': ['Years when a CCT Program was first implemented']})\n",
        "                      ).mark_text(\n",
        "        align='right',\n",
        "        baseline='bottom',\n",
        "        dx=-5,  \n",
        "        dy=190,\n",
        "        color='red',\n",
        "        fontSize=10\n",
        "    ).encode(\n",
        "        x='year:O',\n",
        "        text='label'\n",
        "    )\n",
        "\n",
        "    # Combine the line chart and the vertical lines\n",
        "    final_chart = chart + vertical_lines + label\n",
        "\n",
        "    final_chart.show()\n",
        "\n",
        "    # Save the chart as a PNG file\n",
        "    chart.save(os.path.join(graphs_dir, f\"{var}.png\"))"
      ],
      "id": "af3fa3b1",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "# Education outcomes by country and region type\n",
        "\n",
        "In this section, we analyze the mean values of key outcome variables across Latin American countries with conditional cash transfer (CCT) programs. We calculate the mean for each variable, distinguishing between rural and urban areas, and grouping by the presence or absence of CCT programs. This analysis provides insights into the average impact of CCT programs at the country level. \n"
      ],
      "id": "267931de"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "# List of outcomes to include in the analysis\n",
        "outcomes = ['years_edu_all', 'enrollment6_12yo', 'enrollment13_17yo']\n",
        "\n",
        "# Aggregate data: Calculate the mean for each country and CCT state for each variable\n",
        "aggregated_data = countries_with_cct_df.melt(\n",
        "    id_vars=['country', 'year', 'cct_active'],\n",
        "    value_vars=[f\"{var}_rural\" for var in outcomes] + [f\"{var}_urban\" for var in outcomes],\n",
        "    var_name='variable',\n",
        "    value_name='value'\n",
        ").groupby(['country', 'cct_active', 'variable']).agg(\n",
        "    mean_value=('value', 'mean')\n",
        ").reset_index()\n",
        "\n",
        "aggregated_data['cct_active'] = aggregated_data['cct_active'].replace({0: 'Pre', 1: 'Post'})\n",
        "\n",
        "# Creating custom, informative titles for each plot\n",
        "custom_titles = {\n",
        "    'years_edu_all': 'Years of Education',\n",
        "    'enrollment6_12yo': 'Share of 6- to 12-year-olds Enrolled in School',\n",
        "    'enrollment13_17yo': 'Share of 13- to 17-year-olds Enrolled in School'\n",
        "}\n",
        "\n",
        "# Creating custom, informative y-axis titles for each plot\n",
        "custom_y = {\n",
        "    'years_edu_all': 'Years of Education',\n",
        "    'enrollment6_12yo': 'Enrollment (%)',\n",
        "    'enrollment13_17yo': 'Enrollment (%)'\n",
        "}\n",
        "\n",
        "# Filter the data by each variable and create bar charts\n",
        "for var in outcomes:\n",
        "    data_for_var = aggregated_data[\n",
        "        (aggregated_data['variable'] == f\"{var}_rural\") | (aggregated_data['variable'] == f\"{var}_urban\")\n",
        "    ]\n",
        "\n",
        "    chart = alt.Chart(data_for_var).mark_bar().encode(\n",
        "        x=alt.X('country:N', axis=alt.Axis(title='Country'),\n",
        "                sort=[\"Pre\", \"Post\"]),\n",
        "        y=alt.Y('mean_value:Q', axis=alt.Axis(title=f'Mean {custom_y[var]}')),\n",
        "        color=alt.Color('cct_active:N',\n",
        "                        scale=alt.Scale(domain=['Pre', 'Post'],\n",
        "                                        range=['#363633', '#89a6a5']),  # Celeste and blue\n",
        "                        legend=alt.Legend(title='Cash Transfer',\n",
        "                                          labelFontSize=10,\n",
        "                                          titleFontSize=10),\n",
        "                        sort=[\"Pre\", \"Post\"]),\n",
        "        column='variable:N',\n",
        "        tooltip=['country', 'mean_value', 'cct_active'],\n",
        "        xOffset='cct_active:N'\n",
        "    ).properties(\n",
        "        width=150,\n",
        "        height=400,\n",
        "        title=f\"Mean {custom_titles[var]}: Rural vs. Urban\"\n",
        "    )\n",
        "\n",
        "    chart.show()\n",
        "\n",
        "    # Save the chart as a PNG file\n",
        "    chart.save(os.path.join(graphs_dir, f\"mean_{var}.png\"))"
      ],
      "id": "4183c3b5",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "# Differential growth in years of education and enrollment pre- and post-CCT, per country\n",
        "\n",
        "This section produces graphs showing the differential increse in education outcomes by country, disaggregated by region type.\n"
      ],
      "id": "dca94de2"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "# Create an education df\n",
        "education_agg_df = countries_with_cct_df[['years_edu_all_urban',\n",
        "                                          'enrollment6_12yo_urban', 'enrollment13_17yo_urban',\n",
        "                                          'years_edu_all_rural',\n",
        "                                          'enrollment6_12yo_rural',\n",
        "                                          'enrollment13_17yo_rural',\n",
        "                                          'cct_active',\n",
        "                                          'country',\n",
        "                                          'year']]\n",
        "\n",
        "# Specify outcomes of interest\n",
        "outcomes = ['years_edu_all', 'enrollment6_12yo', 'enrollment13_17yo']\n",
        "\n",
        "# Compute the mean value for each combination of country, cct_active, and variable\n",
        "education_agg_df = education_agg_df.melt(\n",
        "    id_vars=['country', 'year', 'cct_active'],\n",
        "    value_vars=[f\"{var}_rural\" for var in outcomes] +\n",
        "    [f\"{var}_urban\" for var in outcomes],\n",
        "    var_name='variable',\n",
        "    value_name='value'\n",
        ").groupby(['country', 'cct_active', 'variable']).agg(\n",
        "    mean_value=('value', 'mean')\n",
        ").reset_index()\n",
        "\n",
        "# Pivot the table to separate cct_active == 1 and cct_active == 0\n",
        "pivot_df = education_agg_df.pivot_table(\n",
        "    index=['country', 'variable'],\n",
        "    columns='cct_active',\n",
        "    values='mean_value',\n",
        "    aggfunc='mean'\n",
        ").reset_index()\n",
        "\n",
        "# Rename columns more intuitively\n",
        "pivot_df.rename(columns={0: \"Pre\", 1: \"Post\"}, inplace=True)\n",
        "\n",
        "# Create a Rural/Urban variable\n",
        "pivot_df['rural_urban'] = pivot_df['variable'].apply(\n",
        "    lambda x: 'Urban' if 'urban' in x else 'Rural'\n",
        ")\n",
        "\n",
        "# Compute the difference between the mean values pre/post cct \n",
        "pivot_df['mean_difference'] = pivot_df[\"Post\"] - pivot_df[\"Pre\"]\n",
        "\n",
        "########## Plot ############\n",
        "\n",
        "# Create custom, informative titles for each plot\n",
        "custom_titles = {\n",
        "    'years_edu_all': 'Years of Education',\n",
        "    'enrollment6_12yo': 'Share of Children Aged 6-12 Enrolled in School',\n",
        "    'enrollment13_17yo': 'Share of Teenagers Aged 13-17 Enrolled in School'\n",
        "}\n",
        "\n",
        "# Filter the data by each variable and create bar charts\n",
        "for var in outcomes:\n",
        "    data_for_var = pivot_df[pivot_df['variable'].str.contains(var)]\n",
        "\n",
        "    chart = alt.Chart(data_for_var).mark_bar().encode(\n",
        "        x=alt.X('country:N', title='Country'),\n",
        "        y=alt.Y('mean_difference:Q', title='Percentage Point Increase'),\n",
        "        color=alt.Color('rural_urban:N',\n",
        "                        scale=alt.Scale(domain=['Urban', 'Rural'],\n",
        "                                        range=['#363633', '#89a6a5']),  # Celeste and blue\n",
        "                        legend=alt.Legend(title='Region Type',\n",
        "                                          labelFontSize=10,\n",
        "                                          titleFontSize=10)),\n",
        "        xOffset='rural_urban:N',  # Offset the bars to place them side by side\n",
        "        tooltip=['country', 'rural_urban', 'mean_difference']\n",
        "    ).properties(\n",
        "        width=300,\n",
        "        height=400,\n",
        "        title=f'Increase in {custom_titles[var]} Post Cash Transfer'\n",
        "    )\n",
        "\n",
        "    chart.show()\n",
        "\n",
        "    chart.save(os.path.join(graphs_dir, f\"change_{var}.png\"))"
      ],
      "id": "a051bbeb",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "# T-test \n"
      ],
      "id": "6308d504"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "# Drop NAs\n",
        "filtered_data = combined_data.dropna(subset=['years_edu_all', 'enrollment6_12yo', 'enrollment13_17yo'])\n",
        "\n",
        "# Initialize a list to store the results\n",
        "diff_of_diff_results = []\n",
        "\n",
        "# Get the list of unique countries and variables\n",
        "countries = filtered_data['country'].unique()\n",
        "variables = ['years_edu_all', 'enrollment6_12yo', 'enrollment13_17yo']\n",
        "\n",
        "for country in countries:\n",
        "    country_data = filtered_data[filtered_data['country'] == country]\n",
        "    \n",
        "    for variable in variables:\n",
        "        # Filter data for rural and urban areas\n",
        "        rural_data = country_data[country_data['area'] == 'rural']\n",
        "        urban_data = country_data[country_data['area'] == 'urban']\n",
        "        \n",
        "        # Separate data by cct_active (0 and 1) for rural and urban\n",
        "        rural_pre = rural_data[rural_data['cct_active'] == 0][variable]\n",
        "        rural_post = rural_data[rural_data['cct_active'] == 1][variable]\n",
        "        urban_pre = urban_data[urban_data['cct_active'] == 0][variable]\n",
        "        urban_post = urban_data[urban_data['cct_active'] == 1][variable]\n",
        "        \n",
        "        # Calculate the increments (Post - Pre) if data is available\n",
        "        if not rural_pre.empty and not rural_post.empty and not urban_pre.empty and not urban_post.empty:\n",
        "            rural_diff = rural_post.mean() - rural_pre.mean()\n",
        "            urban_diff = urban_post.mean() - urban_pre.mean()\n",
        "            \n",
        "            # Calculate the difference of differences\n",
        "            diff_of_diff = urban_diff - rural_diff\n",
        "            \n",
        "            # Perform a t-test between the increments\n",
        "            rural_increment = rural_post.values - rural_pre.mean()\n",
        "            urban_increment = urban_post.values - urban_pre.mean()\n",
        "            t_stat, p_val = ttest_ind(rural_increment, urban_increment, equal_var=False)\n",
        "            \n",
        "            diff_of_diff_results.append({\n",
        "                'Country': country,\n",
        "                'Variable': variable,\n",
        "                'Rural Increment': rural_diff,\n",
        "                'Urban Increment': urban_diff,\n",
        "                'Difference of Differences': diff_of_diff,\n",
        "                't-stat': t_stat,\n",
        "                'p-value': p_val\n",
        "            })\n",
        "\n",
        "# Convert the results to a DataFrame\n",
        "diff_of_diff_results_df = pd.DataFrame(diff_of_diff_results)\n",
        "\n",
        "# Display the results\n",
        "print(\"Difference of Differences Results:\")\n",
        "print(diff_of_diff_results_df)"
      ],
      "id": "bf11717d",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "# Education and quality of dwellings\n"
      ],
      "id": "26f0102d"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "# Plot of correlation between Education and quality of dwellings by country\n",
        "chart = alt.Chart(countries_with_cct_df).mark_point().encode(\n",
        "    x=alt.X('years_edu_all_rural:Q', axis=alt.Axis(title='Years of Education')),\n",
        "    y=alt.Y('dwellings_low_quality_rural:Q', axis=alt.Axis(title='Share of Poor Dwellings')),\n",
        "    color=alt.Color('country:N', legend=alt.Legend(title='Country',\n",
        "                                          labelFontSize=10,\n",
        "                                          titleFontSize=10))\n",
        ").properties(\n",
        "    width=360,\n",
        "    height=360,\n",
        "    title=\"Poor Dwellings vs. Education\"\n",
        ")\n",
        "\n",
        "\n",
        "chart.show()\n",
        "chart.save(os.path.join(graphs_dir, \"corr_edu_dwelling.png\"))"
      ],
      "id": "e0bf6fc0",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "# Correlation calculation\n"
      ],
      "id": "153da4c2"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "# List of countries\n",
        "countries = [\"Brazil\", \"Chile\", \"Mexico\", \"Peru\", \"Paraguay\"]\n",
        "\n",
        "# Create a dictionary to store the correlations\n",
        "correlations = []\n",
        "\n",
        "# Iterate through each country\n",
        "for country in countries:\n",
        "    # Filter data by country\n",
        "    country_df = countries_with_cct_df[countries_with_cct_df['country'] == country]\n",
        "    \n",
        "    # Check that the relevant columns exist and do not have missing values\n",
        "    if 'dwellings_low_quality_rural' in country_df.columns and 'years_edu_all_rural' in country_df.columns:\n",
        "        # Calculate the correlation if there is enough data\n",
        "        if len(country_df.dropna(subset=['dwellings_low_quality_rural', 'years_edu_all_rural'])) > 1:\n",
        "            correlation = country_df[['dwellings_low_quality_rural', 'years_edu_all_rural']].corr().iloc[0, 1]\n",
        "            correlations.append({'Country': country, 'Correlation': correlation})\n",
        "        else:\n",
        "            correlations.append({'Country': country, 'Correlation': 'Not enough data'})\n",
        "    else:\n",
        "        correlations.append({'Country': country, 'Correlation': 'Data not available'})\n",
        "\n",
        "# Convert the result into a DataFrame\n",
        "correlation_df = pd.DataFrame(correlations)\n",
        "\n",
        "# Display the correlation table in the console\n",
        "print(correlation_df)\n",
        "\n",
        "# Save the results to a CSV file\n",
        "output_path = \"country_correlations.csv\"\n",
        "correlation_df.to_csv(output_path, index=False)\n",
        "print(f\"Correlations saved to '{output_path}'\")"
      ],
      "id": "717b330f",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "# Quality of Dwellings post-CCT, graph \n"
      ],
      "id": "89d7ab2e"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "countries = [\"Brazil\", \"Chile\", \"Mexico\", \"Peru\", \"Paraguay\"]\n",
        "\n",
        "implementation_years = {\"Brazil\" : 2003,\n",
        "                         \"Chile\" : 2002,\n",
        "                         \"Mexico\": 1997,\n",
        "                         \"Peru\" : 2005,\n",
        "                         \"Paraguay\": 2005}\n",
        "\n",
        "\n",
        "for country in countries:\n",
        "    country_df = countries_with_cct_df[countries_with_cct_df[\"country\"] == country]\n",
        "\n",
        "    chart = alt.Chart(country_df).mark_point().encode(\n",
        "        x=alt.X('year:O', axis=alt.Axis(title='Year')), \n",
        "        y=alt.Y('dwellings_low_quality_rural:Q',\n",
        "                axis=alt.Axis(title='Share of Poor Dwellings'))\n",
        "    ).properties(\n",
        "        width=360,\n",
        "        height=360,\n",
        "        title= f\"Share of Poor Dwellings in {country}'s Rural Areas Before and After CCT Implementation\"\n",
        "    )\n",
        "\n",
        "    vertical_line = alt.Chart(pd.DataFrame({'year': [implementation_years[country]]})).mark_rule(color='red').encode(\n",
        "        x='year:O'  \n",
        "    )\n",
        "\n",
        "    plot = chart + vertical_line\n",
        "\n",
        "    plot.show()\n",
        "    chart.save(os.path.join(graphs_dir, f\"dwelling_{country}.png\"))"
      ],
      "id": "c1889103",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "# Regression Analysis\n",
        "\n",
        "In this section, we perform a correlation analysis to explore the relationships between key variables and the implementation of conditional cash transfer (CCT) programs. We separately analyze rural and urban areas, focusing on variables related to education outcomes, infrastructure, and living conditions.\n"
      ],
      "id": "032355a8"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "# Relevant columns for rural and urban areas\n",
        "relevant_columns_rural = [\n",
        "    'cct_active', 'enrollment3_5yo_rural', 'enrollment6_12yo_rural',\n",
        "    'enrollment13_17yo_rural', 'years_edu_all_rural', 'water_rural',\n",
        "    'electricity_rural', 'hygienic_restrooms_rural', 'sewerage_rural',\n",
        "    'dwellings_low_quality_rural', 'country', 'year'\n",
        "]\n",
        "\n",
        "relevant_columns_urban = [\n",
        "    'cct_active', 'enrollment3_5yo_urban', 'enrollment6_12yo_urban',\n",
        "    'enrollment13_17yo_urban', 'years_edu_all_urban', 'water_urban',\n",
        "    'electricity_urban', 'hygienic_restrooms_urban', 'sewerage_urban',\n",
        "    'dwellings_low_quality_urban', 'country', 'year'\n",
        "]\n",
        "\n",
        "# Ensure valid columns are present\n",
        "relevant_columns_rural = [col for col in relevant_columns_rural if col in countries_with_cct_df.columns]\n",
        "relevant_columns_urban = [col for col in relevant_columns_urban if col in countries_with_cct_df.columns]\n",
        "\n",
        "# Filter datasets\n",
        "cct_data_corr_rural = countries_with_cct_df[relevant_columns_rural].dropna()\n",
        "cct_data_corr_urban = countries_with_cct_df[relevant_columns_urban].dropna()\n",
        "\n",
        "# Check dataset shapes\n",
        "print(f\"Rural data shape: {cct_data_corr_rural.shape}\")\n",
        "print(f\"Urban data shape: {cct_data_corr_urban.shape}\")\n",
        "\n",
        "#### Correlation analysis in rural areas ####\n",
        "#############################################\n",
        "\n",
        "# Exclude non-numeric columns for correlation analysis - rural\n",
        "numeric_columns_rural = cct_data_corr_rural.select_dtypes(include=['float64', \"int64\", 'int32']).columns\n",
        "correlation_matrix_rural = cct_data_corr_rural[numeric_columns_rural].corr()\n",
        "\n",
        "# Focus on correlations with `cct_active` in rural areas\n",
        "cct_correlations_rural = correlation_matrix_rural['cct_active'].sort_values(ascending=False)\n",
        "print(\"\\nCorrelations with CCT Active (Rural):\")\n",
        "print(cct_correlations_rural)\n",
        "\n",
        "#### Correlation analysis in urban areas ####\n",
        "#############################################\n",
        "\n",
        "# Exclude non-numeric columns for correlation analysis - urban\n",
        "numeric_columns_urban = cct_data_corr_urban.select_dtypes(include=['float64', 'int64', \"int32\"]).columns\n",
        "correlation_matrix_urban = cct_data_corr_urban[numeric_columns_urban].corr()\n",
        "\n",
        "# Focus on correlations with `cct_active`\n",
        "cct_correlations_urban = correlation_matrix_urban['cct_active'].sort_values(ascending=False)\n",
        "print(\"\\nCorrelations with CCT Active (Urban):\")\n",
        "print(cct_correlations_urban)"
      ],
      "id": "ccf3ed62",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "In this section, we conduct fixed effects regressions to examine the relationship between the implementation of conditional cash transfer (CCT) programs and key educational outcomes in rural and urban areas. The regressions are run separately for rural and urban datasets, allowing us to identify differences in the impact of CCT programs across these contexts. By using a fixed effects approach, we account for unobserved heterogeneity within countries over time, providing robust estimates of the effects of the CCT programs. \n"
      ],
      "id": "d7fc9fa8"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "# Set the index (for fixed effects regression)\n",
        "cct_data_corr_rural = cct_data_corr_rural.set_index(['country', 'year'])\n",
        "cct_data_corr_urban = cct_data_corr_urban.set_index(['country', 'year'])\n",
        "\n",
        "# Explanatory variables for rural and urban\n",
        "explanatory_vars_rural = ['cct_active', 'electricity_rural', 'sewerage_rural',\n",
        "                          'hygienic_restrooms_rural', 'water_rural']\n",
        "explanatory_vars_urban = ['cct_active', 'electricity_urban', 'sewerage_urban',\n",
        "                          'hygienic_restrooms_urban', 'water_urban']\n",
        "\n",
        "# Outcome variables (including dwellings_low_quality)\n",
        "outcome_vars = ['years_edu_all', 'enrollment3_5yo', 'enrollment6_12yo', 'enrollment13_17yo', \n",
        "                'dwellings_low_quality']\n",
        "\n",
        "# Function to fit the fixed effects model\n",
        "def run_fixed_effects(data, outcomes, explanatory_vars, region):\n",
        "    print(f\"\\n--- Fixed Effects Regressions for {region.capitalize()} Data ---\\n\")\n",
        "    for outcome in outcomes:\n",
        "        outcome_var = f\"{outcome}_{region}\"\n",
        "        if outcome_var in data.columns:\n",
        "            # Dependent and independent variables\n",
        "            y = data[outcome_var]\n",
        "            X = sm.add_constant(data[explanatory_vars])\n",
        "            \n",
        "            # Fit the model\n",
        "            model = PanelOLS(y, X, entity_effects=True).fit()\n",
        "            \n",
        "            # Display results\n",
        "            print(f\"Fixed Effects Results for {outcome.capitalize()} ({region.capitalize()}):\")\n",
        "            print(model.summary)\n",
        "            print(\"\\n\")\n",
        "        else:\n",
        "            print(f\"Outcome variable '{outcome_var}' not found in {region} dataset.\")\n",
        "\n",
        "# Run the regression for rural and urban data\n",
        "run_fixed_effects(cct_data_corr_rural, outcome_vars, explanatory_vars_rural, 'rural')\n",
        "run_fixed_effects(cct_data_corr_urban, outcome_vars, explanatory_vars_urban, 'urban')"
      ],
      "id": "c3755efa",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "# Dif in Dif\n"
      ],
      "id": "f0b70456"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "# Function to perform Difference-in-Differences analysis\n",
        "def run_did_analysis(data, outcomes, region):\n",
        "    print(f\"\\n--- Difference-in-Differences Analysis for {region.capitalize()} Data ---\\n\")\n",
        "    results = []\n",
        "    \n",
        "    # Reset index temporarily to access 'year'\n",
        "    data = data.reset_index()\n",
        "    \n",
        "    for outcome in outcomes:\n",
        "        outcome_var = f\"{outcome}_{region}\"\n",
        "        \n",
        "        if outcome_var in data.columns:\n",
        "            # Define the pre/post indicator\n",
        "            data['post'] = data['year'] >= data['year'].median()  # Define pre/post as before/after median year\n",
        "            data['post'] = data['post'].astype(int)\n",
        "            \n",
        "            # Fit the DiD model\n",
        "            formula = f\"{outcome_var} ~ cct_active + post + cct_active:post\"\n",
        "            model = smf.ols(formula, data=data).fit()\n",
        "            \n",
        "            # Extract results for the interaction term\n",
        "            interaction_coeff = model.params.get('cct_active:post', None)\n",
        "            p_value = model.pvalues.get('cct_active:post', None)\n",
        "            \n",
        "            # Store results\n",
        "            results.append({\n",
        "                'Outcome': outcome_var,\n",
        "                'Interaction_Coeff': interaction_coeff,\n",
        "                'p-value': p_value\n",
        "            })\n",
        "            \n",
        "            # Display the summary\n",
        "            print(f\"DiD Results for {outcome} ({region.capitalize()}):\")\n",
        "            print(model.summary())\n",
        "            print(\"\\n\")\n",
        "        else:\n",
        "            print(f\"Outcome variable '{outcome_var}' not found in {region} dataset.\")\n",
        "    \n",
        "    # Return results as DataFrame\n",
        "    return pd.DataFrame(results)\n",
        "\n",
        "# Define datasets and outcomes\n",
        "outcomes = ['years_edu_all', 'enrollment6_12yo', 'enrollment13_17yo', 'dwellings_low_quality']\n",
        "regions = ['rural', 'urban']\n",
        "\n",
        "# Example for running the analysis\n",
        "did_results_rural = run_did_analysis(cct_data_corr_rural, outcomes, 'rural')\n",
        "did_results_urban = run_did_analysis(cct_data_corr_urban, outcomes, 'urban')\n",
        "\n",
        "# Combine results\n",
        "final_did_results = pd.concat([did_results_rural, did_results_urban])\n",
        "print(\"\\nFinal DiD Results:\")\n",
        "print(final_did_results)\n",
        "\n",
        "# Save results to CSV\n",
        "final_did_results.to_csv(\"did_results_with_dwellings.csv\", index=False)"
      ],
      "id": "ddca3c66",
      "execution_count": null,
      "outputs": []
    }
  ],
  "metadata": {
    "kernelspec": {
      "name": "python3",
      "language": "python",
      "display_name": "Python 3 (ipykernel)",
      "path": "C:\\Users\\solch\\AppData\\Roaming\\Python\\share\\jupyter\\kernels\\python3"
    }
  },
  "nbformat": 4,
  "nbformat_minor": 5
}